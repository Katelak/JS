# JS

В JavaScript "scope" (область видимости) определяет, где переменные, функции и объекты могут быть доступны в программе. Важно понимать, какие переменные и функции доступны в разных частях программы. Существует несколько типов областей видимости в JavaScript:

1. **Global Scope (Глобальная область видимости)**:
   - Это область, доступная во всей программе. Все переменные, объявленные в глобальной области, могут быть использованы в любой части программы.
   - Пример:
     ```javascript
     let globalVar = 'I am global'; // глобальная переменная
     function showGlobalVar() {
       console.log(globalVar); // доступ к глобальной переменной
     }
     showGlobalVar(); // Выведет: I am global
     ```

2. **Function Scope (Область видимости функции)**:
   - Переменные, объявленные внутри функции, доступны только внутри этой функции. Эти переменные недоступны за её пределами.
   - Пример:
     ```javascript
     function myFunction() {
       let localVar = 'I am local'; // локальная переменная
       console.log(localVar); // доступ к локальной переменной
     }
     myFunction(); // Выведет: I am local
     console.log(localVar); // Ошибка: localVar не определена
     ```

3. **Block Scope (Область видимости блока)**:
   - Введена в ES6 с помощью `let` и `const`. Эти переменные доступны только в том блоке кода, в котором они были объявлены (например, внутри цикла или условного блока).
   - Пример:
     ```javascript
     if (true) {
       let blockVar = 'I am block scoped';
       console.log(blockVar); // Выведет: I am block scoped
     }
     console.log(blockVar); // Ошибка: blockVar не определена
     ```

4. **Lexical Scope (Лексическая область видимости)**:
   - Лексическая область видимости означает, что область видимости определяется местоположением функции в исходном коде, а не тем, как и откуда она была вызвана.
   - Пример:
     ```javascript
     function outer() {
       let outerVar = 'I am outside';
       function inner() {
         console.log(outerVar); // Внутренняя функция имеет доступ к переменной внешней функции
       }
       inner();
     }
     outer(); // Выведет: I am outside
     ```

5. **Module Scope (Область видимости модуля)**:
   - В случае использования модулей (например, в ES6 с `import/export`), каждая переменная, объявленная внутри модуля, имеет область видимости, ограниченную этим модулем.
   - Пример:
     ```javascript
     // В module.js
     let moduleVar = 'I am module scoped';
     export function showModuleVar() {
       console.log(moduleVar);
     }

     // В другом файле
     import { showModuleVar } from './module.js';
     showModuleVar(); // Выведет: I am module scoped
     ```

6. **Eval Scope (Область видимости eval)**:
   - В коде, исполняемом внутри функции `eval()`, создаются новые переменные в области видимости, в которой был вызван `eval()`. Однако использование `eval()` не рекомендуется, поскольку это может привести к сложным для отслеживания ошибкам.
   - Пример:
     ```javascript
     let x = 10;
     eval('let x = 20; console.log(x);'); // Выведет: 20
     console.log(x); // Выведет: 10 (глобальная переменная x не была изменена)
     ```

В JavaScript переменные могут быть видны только в рамках определенной области видимости, и понимание области видимости важно для правильной организации кода и предотвращения ошибок с доступом к данным.

**Hoisting** (всплытие) в JavaScript — это механизм, при котором объявления переменных и функций "всплывают" (или поднимаются) в верхнюю часть своей области видимости перед выполнением кода. Однако важно понимать, что **всплывают только объявления**, а не присваивания значений.

### Как работает hoisting?

1. **Объявления переменных (с использованием `var`)**:
   - Переменные, объявленные с помощью `var`, поднимаются в верхнюю часть своей области видимости (функции или глобальной области), но только их **объявление**, а не **инициализация**. Это значит, что переменная будет доступна до её реального присваивания значения, но её значение будет `undefined`.

   Пример:
   ```javascript
   console.log(a); // undefined, а не ошибка
   var a = 5;
   console.log(a); // 5
   ```

   Здесь переменная `a` поднимется вверх, но присваивание значения `5` произойдёт только на той строке, где это указано.

2. **Объявления переменных (с использованием `let` и `const`)**:
   - Переменные, объявленные с помощью `let` и `const`, также поднимаются в верхнюю часть области видимости, но они **не инициализируются** до того, как интерпретатор доберётся до строки с их объявлением. Это создаёт так называемую **временную мёртвую зону (TDZ)**, где доступ к переменной до её инициализации вызывает ошибку.

   Пример:
   ```javascript
   console.log(b); // Ошибка: Cannot access 'b' before initialization
   let b = 10;
   ```

   В случае с `let` и `const`, переменная доступна только после того, как она была инициализирована, и попытка использовать её до инициализации вызовет ошибку.

3. **Объявления функций**:
   - **Функции**, объявленные с использованием **function declaration** (например, `function foo() {...}`), также поднимаются целиком, включая тело функции. Это означает, что функцию можно вызвать до её фактического объявления в коде.

   Пример:
   ```javascript
   greet(); // "Hello!"
   function greet() {
     console.log("Hello!");
   }
   ```

   В этом примере вызов `greet()` возможен до её определения, потому что сама функция "всплывает" с её телом.

4. **Функции, объявленные как выражения (function expressions)**:
   - Если функция объявлена как выражение (например, через присваивание), то только переменная, которая хранит эту функцию, будет всплывать. Однако саму функцию нельзя вызвать до того, как она будет определена.

   Пример:
   ```javascript
   myFunc(); // TypeError: myFunc is not a function
   var myFunc = function() {
     console.log("Hello!");
   };
   ```

   В этом случае переменная `myFunc` будет поднята, но присваивание функции произойдёт только после строки с присваиванием. До этого момента `myFunc` будет иметь значение `undefined`, и попытка её вызова приведёт к ошибке.

### Итоги:

- **`var`**: Поднимается объявление переменной, но не присваивание. Значение переменной будет `undefined` до присваивания.
- **`let` и `const`**: Поднимаются объявления, но инициализация происходит в области временной мёртвой зоны (TDZ), что приводит к ошибке, если переменная используется до её инициализации.
- **Function declarations**: Функции, объявленные через `function`, полностью поднимаются (объявление и тело функции).
- **Function expressions**: Функции, объявленные как выражения (например, через `var` или `let`), не могут быть вызваны до их объявления.

**Hoisting** — это полезное поведение, но его нужно понимать, чтобы избежать ошибок и неправильного использования переменных и функций.
